### **Firectl 技术方案 (V1.0)**

#### 1\. 项目概述 (Project Overview)

**项目名称**: Firectl - 一个基于 Firecracker 的迷你安全容器引擎

**目标**: 创建一个命令行工具 (`firectl`)，该工具能够获取标准 OCI 容器镜像，并将其作为根文件系统在 Firecracker microVM 中启动。以此实现一个比传统容器具有更强安全隔离性的应用运行时。

**核心范围 (MVP)**:

  * 实现 `firectl run <image>` 命令，完成从镜像到运行中 VM 的全过程。
  * 实现 `firectl list` 命令，展示由 `firectl` 管理的正在运行的 VM。
  * 实现 `firectl stop <vm-id>` 命令，用于终止和清理指定的 VM。

#### 2\. 系统架构 (System Architecture)

Firectl 采用 C/S (客户端/服务) 模型，其中 `firectl` CLI 是客户端，每个 `firecracker` 进程本身是一个微型服务。CLI 负责准备资源并管理 `firecracker` 进程的生命周期。

**工作流程图**:

```
+-------------+      1. pull/export       +------------------+
|   User      | ------------------------> |   Docker Daemon  |
| (firectl run)|      (via CLI cmd)        +------------------+
+-------------+             |
      | 2. firectl receives rootfs.tar
      |
      v
+-----------------------------+     3. create/format/mount/untar     +--------------------+
|     Firectl CLI Process     | -----------------------------------> |  rootfs.ext4 (File)|
|                             | <----------------------------------- |                    |
| - Manages VM state          |      4. unmount                      +--------------------+
| - Generates config.json     |
| - Interacts with Firecracker|
+-----------------------------+
      |
      | 5. Launch firecracker process
      |
      v
+-----------------------------+     6. Configure via REST API        +--------------------+
|  Firecracker Process (PID)  | <----------------------------------- | API Socket (.sock) |
|  - Runs the microVM         |                                      +--------------------+
+-----------------------------+
      |
      | 7. VM is Running (Guest Kernel + rootfs)
      v
+-----------------------------+
|    Running MicroVM          |
|  (e.g., nginx inside)       |
+-----------------------------+
```

#### 3\. 模块详细设计 (Module Detailed Design)

项目将采用 Go 语言编写，并遵循标准的 Go 项目布局。

```
firectl/
├── cmd/firectl/            # CLI 入口 (Cobra library)
│   └── main.go
├── pkg/
│   ├── manager/            # 核心 VM 管理器
│   │   └── manager.go
│   ├── image/              # 镜像处理 (调用 docker)
│   │   └── handler.go
│   ├── rootfs/             # Rootfs 创建与管理
│   │   └── creator.go
│   ├── firecracker/        # 与 Firecracker API 交互的客户端
│   │   └── client.go
│   └── state/              # 管理 firectl 状态 (vms.json)
│       └── store.go
├── scripts/                # 辅助脚本 (如: 下载内核)
└── README.md
```

**3.1 `cmd/firectl` - CLI 接口层**

  * **技术**: 使用 `github.com/spf13/cobra` 构建现代化的命令行工具。
  * **职责**:
      * 定义 `run`, `list`, `stop` 等命令及其参数（flags）。
      * 解析用户输入，进行基本的合法性校验。
      * 调用 `pkg/manager` 中的对应函数来执行核心逻辑。
      * 处理用户输出（打印表格、状态信息等）。

**3.2 `pkg/manager` - 核心 VM 管理器**

  * **职责**: 业务流程编排。
  * **`RunVM(imageName string, config VMConfig)` 函数**:
    1.  调用 `image.PullAndExport(imageName)` 获取 rootfs tar 包路径。
    2.  调用 `rootfs.Create(tarPath)` 创建并准备好 `rootfs.ext4` 文件，返回其路径。
    3.  生成一个唯一的 UUID 作为 VM ID。
    4.  准备 Firecracker 的配置（内核路径、rootfs 路径、CPU、内存等）。
    5.  调用 `firecracker.NewClient(socketPath)` 创建 API 客户端。
    6.  启动一个新的 goroutine 来执行 `firecracker.LaunchVM()`。
    7.  `LaunchVM` 内部首先启动 `firecracker` 二进制进程，然后通过 API Client 配置并启动 VM。
    8.  VM 启动成功后，获取 `firecracker` 进程的 PID。
    9.  调用 `state.AddVM()` 将 VM 信息（ID, PID, ImageName, SocketPath 等）持久化。

**3.3 `pkg/image` - 镜像处理器**

  * **职责**: 封装对外部 Docker CLI 的调用。
  * **`PullAndExport(imageName string) (string, error)` 函数**:
    1.  `exec.Command("docker", "pull", imageName).Run()`
    2.  `exec.Command("docker", "create", imageName).Output()` 获取容器 ID。
    3.  `exec.Command("docker", "export", containerID, "-o", tarPath).Run()` 导出 tar 文件。
    4.  返回 `tarPath` 和 `nil` 错误。

**3.4 `pkg/rootfs` - Rootfs 创建器**

  * **职责**: 封装对 `dd`, `mkfs.ext4`, `mount` 等系统命令的调用。**此模块需要 sudo 权限执行**。
  * **`Create(tarPath string) (string, error)` 函数**:
    1.  生成 ext4 文件路径，例如 `/var/lib/firectl/rootfs/<vm-id>.ext4`。
    2.  `exec.Command("dd", ...)` 创建一个稀疏文件（sparse file）以提高效率。
    3.  `exec.Command("mkfs.ext4", ...)` 格式化文件。
    4.  创建临时挂载点 `mkdir -p /mnt/firectl/<vm-id>`。
    5.  `exec.Command("mount", "-o", "loop", ...)` 挂载 ext4 文件。
    6.  `exec.Command("tar", "-xf", tarPath, "-C", mountPoint)` 解压。
    7.  `exec.Command("umount", mountPoint)` 卸载。
    8.  返回 ext4 文件路径。

**3.5 `pkg/firecracker` - Firecracker API 客户端**

  * **职责**: 启动 Firecracker 进程并与其 API Socket 交互。
  * **`LaunchVM(...)`**:
    1.  `exec.Command("firecracker", "--api-sock", socketPath)` 启动进程。记录进程 PID。
    2.  创建一个配置了 `http.UnixDial` 的 `http.Client`，使其能通过 socket 通信。
    3.  发送 `PUT /boot-source` 请求，内容为内核路径和启动参数。
    4.  发送 `PUT /drives/rootfs` 请求，内容为 `rootfs.ext4` 的路径。
    5.  发送 `PUT /machine-config` 请求，配置 vCPU 和内存。
    6.  发送 `PUT /actions` 请求，内容为 `{"action_type": "InstanceStart"}` 来启动VM。

**3.6 `pkg/state` - 状态存储**

  * **职责**: 管理 JSON 格式的状态文件。
  * **位置**: `~/.config/firectl/vms.json`。
  * **功能**: 提供 `AddVM`, `GetVM`, `RemoveVM`, `ListVMs` 等 CRUD 方法。
  * **注意**: 读写文件时需要实现文件锁，防止并发操作时数据损坏。

#### 4\. 数据模型 (Data Model)

状态文件 `vms.json` 将是一个 VM 对象列表：

```json
[
  {
    "id": "c1a9b2b0-d2c1-4b6a-8f0a-1b2c3d4e5f6g",
    "imageName": "nginx:latest",
    "state": "Running",
    "firecrackerPid": 12345,
    "vmSocketPath": "/tmp/firecracker-c1a9.sock",
    "rootfsPath": "/var/lib/firectl/rootfs/c1a9.ext4",
    "kernelPath": "/var/lib/firectl/kernels/vmlinux-5.10",
    "createdAt": "2025-07-23T14:00:00Z"
  }
]
```

对应的 Go `struct` 将定义在 `pkg/state/store.go` 中。

#### 5\. 关键技术选型与理由

  * **Go**: 云原生领域标准语言，静态编译、部署简单，并发模型（goroutine）适合处理 I/O 密集型任务和启动子进程。
  * **Firecracker**: 项目核心，提供高性能、低开销的 microVM，安全隔离性强。
  * **Docker CLI (MVP 阶段)**: 快速实现原型。避免在初期阶段陷入处理 OCI 镜像格式的复杂性中，让我们能聚焦于与 Firecracker 的集成。
  * **JSON 文件 (状态存储)**: 简单、人类可读、无需外部数据库依赖，完全符合项目 MVP 阶段的需求。
  * **Cobra (CLI 库)**: 功能强大，社区活跃，能轻松构建出专业级的命令行工具。

#### 6\. 开发与实施计划 (Milestones)

1.  **M1: 环境准备与最小化启动 (3-4 天)**

      * 搭建 Go 开发环境，初始化项目结构。
      * 编写一个简单的 Go 程序，能够直接通过 `exec.Command` 启动一个预先配置好（手动创建 config.json）的 Firecracker VM。
      * 目标：验证 Firecracker 的基本工作流程。

2.  **M2: 实现核心 `run` 流程 (1 周)**

      * 完成 `pkg/image` 和 `pkg/rootfs` 模块，实现从 Docker 镜像到 `rootfs.ext4` 的自动化转换。
      * 完成 `pkg/firecracker` 模块，实现通过 API 动态配置并启动 VM。
      * 将以上模块在 `pkg/manager` 中串联起来，完成 `firectl run` 的核心逻辑。

3.  **M3: 实现生命周期管理 (3-4 天)**

      * 完成 `pkg/state` 模块，实现 VM 信息的持久化。
      * 基于状态存储，实现 `firectl list` 和 `firectl stop` 命令。
      * `stop` 命令需要能正确清理（kill 进程、删除 rootfs 和 socket 文件）。

4.  **M4: 打包与文档 (2 天)**

      * 完善代码注释和错误处理。
      * 编写一份详细的 `README.md`，包括项目介绍、如何编译、如何使用、以及必要的前置条件（如安装 Docker、下载内核文件等）。

#### 7\. 风险与挑战 (Risks & Challenges)

  * **权限问题**: `pkg/rootfs` 模块中的 `mount` 等操作需要 `sudo` 权限。需要在文档中明确指出，并考虑如何以更安全的方式处理（例如，在首次运行时提示用户设置免密 sudo 权限）。
  * **环境依赖**: 项目强依赖 Linux 环境（因为 `ext4` 和 `loop` 设备）。需要在文档中声明不支持 macOS 和 Windows。
  * **内核兼容性**: Guest Kernel 必须与 rootfs 中的 glibc 版本以及 Firecracker 的设备模型兼容。需要提供一个经过测试、确定可用的内核文件下载链接。
  * **清理逻辑**: 异常退出时（如 `run` 过程中断），可能会留下垃圾文件（未完成的 rootfs、socket 等）。需要设计健壮的清理机制。